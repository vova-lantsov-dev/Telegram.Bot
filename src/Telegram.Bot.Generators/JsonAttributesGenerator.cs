using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Telegram.Bot.Generators
{
    [Generator]
    public sealed class JsonAttributesGenerator : ISourceGenerator
    {
        // ==============================

        private const string Placeholder = @"// <auto-generated />
using System.ComponentModel.DataAnnotations;
using System.Text.Json.Serialization;

namespace {0}
{{
    public interface IAutoGenerated{1}
    {{
{2}
    }}
}}
";

        // ==============================

        private const string PropertyPlaceholder = @"        [JsonPropertyName(""{0}"")]
        {1} {2} {{ get; }}";

        // ==============================

        private const string NewLinePlaceholder = @"

";

        // ==============================

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new JsonAttributesSyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (context.SyntaxReceiver is not JsonAttributesSyntaxReceiver receiver)
                return;

            Compilation compilation = context.Compilation;

            INamedTypeSymbol jsonPropertyNameAttr =
                compilation.GetTypeByMetadataName("System.Text.Json.JsonPropertyNameAttribute");
            INamedTypeSymbol jsonIgnoreAttribute =
                compilation.GetTypeByMetadataName("System.Text.Json.JsonIgnoreAttribute");

            foreach (TypeDeclarationSyntax typeSyntax in receiver.Candidates)
            {
                SemanticModel model = compilation.GetSemanticModel(typeSyntax.SyntaxTree);
                ITypeSymbol type = (ITypeSymbol) model.GetDeclaredSymbol(typeSyntax);

                var properties = new List<string>();

                foreach (IPropertySymbol prop in type!.GetMembers().OfType<IPropertySymbol>()
                    .Where(p => p.DeclaredAccessibility == Accessibility.Public &&
                                p.GetMethod != null && p.SetMethod != null))
                {
                    // skip this property if it already has the JsonIgnoreAttribute or the JsonPropertyNameAttribute
                    ImmutableArray<AttributeData> attributes = prop.GetAttributes();
                    var skip = false;
                    foreach (AttributeData attribute in attributes)
                    {
                        if (SymbolEqualityComparer.Default.Equals(attribute.AttributeClass, jsonPropertyNameAttr) ||
                            SymbolEqualityComparer.Default.Equals(attribute.AttributeClass, jsonIgnoreAttribute))
                        {
                            skip = true;
                            break;
                        }
                    }

                    if (skip)
                        continue;

                    // declare the variables for GetPropertyPlaceholder method
                    string propertyName = prop.Name;
                    string propertyFullTypeName =
                        prop.Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                    // get the property placeholder text and append it to the list
                    string propertyPlaceholder =
                        GetPropertyPlaceholder(propertyName, propertyFullTypeName);
                    properties.Add(propertyPlaceholder);
                }

                // declare the variables for GetPlaceholder method
                string namespaceName = type.ContainingNamespace.ToString();
                string classNameWithTypeParameters = type.ToString().Split('.').Last();
                string content = string.Join(NewLinePlaceholder, properties);

                // get the auto-generated source code for this record type and apply it to the compilation context
                string recordPlaceholder = GetPlaceholder(namespaceName, classNameWithTypeParameters, content);
                context.AddSource($"I{type.Name}_generated.cs", recordPlaceholder);
            }
        }

        private static string GetPlaceholder(string namespaceName, string classNameWithTypeParameters, string content)
        {
            return string.Format(Placeholder, namespaceName, classNameWithTypeParameters, content);
        }

        private static string GetPropertyPlaceholder(string propertyName, string propertyFullTypeName)
        {
            string snakeCasePropertyName = propertyName.ToSnakeCase();
            return string.Format(PropertyPlaceholder, snakeCasePropertyName, propertyFullTypeName, propertyName);
        }
    }
}
